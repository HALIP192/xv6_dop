# Лаборатораня работа: системные вызовы

## Введение

В предыдущей лабораторной работе вы исполоьзовали системные вызовы для
написания несколько утилит. В этой же лабораторной работе вы добавите в xv6 
несколько новых системных вызовов, которые помогут вам разобраться как они 
(вызовы) работают и познакомят с некоторыми внутренностями ядра xv6. Вам 
предстоит добавить больше системных вызовов в последующих лабораторных работах.

> Перед тем как начать кодить, прочитайте главу 2 из книги xv6, а также секции
> 4.3 и 4.4 из главы 4, и связанные с ними исходные файлы:  
> * Стабы для пользовательского окружения, которые соединяют системные вызовы
> с ядром, находятся в файле user/usys.S, который генерируется из user/usys.pl, 
> когда запускаете make. Объявление вызовов находится в user/user.h
> * Код окружения ядра, который соединяет системные вызовы c ядровыми 
> функциями, которые имплементируются в файлах kernel/syscall.c
> и kernel/syscall.h
> * Код связаный с процессами, располагается в kernel/proc.h и kernel/proc.c

Начнем лабораторную с того, что переключимся на ветку **syscall**:

    $ git fetch
    $ git checkout syscall
    $ make clean

Если вы запустите *make grade*, то увидите как оценивающий скрипт не может 
выполнить trace и sysinfotest. Ваша задача добавить необходимые системыне 
вызовы и стабы для их работы.

## Введение в gdb

В большинстве случаях, использование команды print будет достаточно, для 
отладки вашего ядра, но иногда полезно иметь возможность шаг за шагом 
выполнить какой-либо ассемблерный код или проверить переменные на стеке.

Давайте изучим как запустить GDB и какие проблемы обыно возникают, когда 
используют этот инструмент, проверь эту 
[страницу](https://pdos.csail.mit.edu/6.828/2023/labs/gdb.html)

Что бы помочь вам познакомиться с инструментом gdb, выполни команду 
*make qemu-gdb*, а затем запустите gdb в другом окне 
(see the gdb bullet on the guidance page). Как только откроются оба окна, 
введите в окне с gdb следующие строки:

    (gdb) b syscall
    Breakpoint 1 at 0x80002142: file kernel/syscall.c, line 243.
    (gdb) c
    Continuing.
    [Switching to Thread 1.2]

    Thread 2 hit Breakpoint 1, syscall () at kernel/syscall.c:243
    243     {
    (gdb) layout src
    (gdb) backtrace

Используя команду *layout* разделим окно на два, показывающее где находится 
gdb  в исходном коде. Команда *backtrace* напечатает стек вызовов функций. 
См. 
[Using the GNU Debugger](https://pdos.csail.mit.edu/6.828/2019/lec/gdb_slides.pdf), 
что бы познакомиться с командами GDB поближе.

> P.S.: отвечать на вопросы в answers-syscall.txt не надо пока.

Ответьте на следующие вопросы в answers-syscall.txt.

> ❓ Вопрос: рассмотрим вывод команды *backtrace* более подробно. Какая 
> функция вызвала *syscall*?

Напечатайте *n* несколько раз, что бы перейти к *proc \*p = myproc();* 
После выполнения этих манипуляций, введите *p /x \*p*, которая напечатает 
текущее значение структуры процесса (более подробно см. в kernel/proc.h) 
в шестнадцеричном виде.

> Каково значение перменной у \*p->trapframe->a7 и что оно означает? 
(Подсказка: посмотрите файл user/initcode.S, запускается первая 
пользовательская программа).

Процессор запущен в привелигированном режиме и мы можем распечатать 
привилегированные регистры, такие как *sstatus* 
(см. описание прилигированные инструкций для RISC-V):

    (gdb) p /x $sstatus

> В каком режиме был ранее ЦПУ?

В последующих частях этой лаборатоной (или в других лабах), может случится 
ситуация, в которой ваша ошибка в программе приводит к панике ядра xv6. 
Например, давайте заменим выражение *num = p->trapfram->a7;* на 
*num = \* (int \*) 0;* в начале *syscall*, и сделаем *make qemu*. 
В результате, вы сможетет увидеть что-то похожее на:

    xv6 kernel is booting

    hart 2 starting
    hart 1 starting
    scause 0x000000000000000d
    sepc=0x000000008000215a stval=0x0000000000000000
    panic: kerneltrap
  
Выйдем из *qemu*.

Что бы найти источник паники, который произошел из-за сбоя страниц посмотрите
значение **sepc**, распечатанное из-за паники и найдите этот адрес в файле
kernel/kernel.asm, который содержит скомпилированный код ядра.

> Напишите ассемблерную инструкцию ядра из-за которой произошла паника. 
> Какой регистр соответсвтвует переменной **num**?

Что бы проверить состояние процессора и ядра при сбое инструкции, запустите gdb
и установите точку остановки на адресе **sepc**, как сделано здесь:

    (gdb) b *0x000000008000215a
    Breakpoint 1 at 0x8000215a: file kernel/syscall.c, line 247.
    (gdb) layout asm
    (gdb) c
    Continuing.
    [Switching to Thread 1.3]

    Thread 3 hit Breakpoint 1, syscall () at kernel/syscall.c:247
    
Проверьте, что падающая ассемблерная инструкция совпдаает с тем что 
вы нашли ранее.


> Почему ядро ломается?

Обратите внимание, что **scause** был также распечатан при панике ядра
(см. выше), но зачастую нам необходимо посмотреть дополнительную информацию
для выяснения причины возникновения паники. Например, давайте узнаем, какой
пользовательский процесс был запущен, когда возникла паника. Для этого вам
надо распечатать имя процесса:

    (gdb) p p->name
  
> Как называется исполняемый файл, запущенный во время паники ядра? Назовите 
id запущенного процесса.

На этом мы завершаем краткое введение в способах применения gdb; советуем
потратить ваша вермя и посетить 
[Using the GNU Debugger](https://pdos.csail.mit.edu/6.828/2019/lec/gdb_slides.pdf), 
при отслелижвании ошибок в ядре.

## Системные вызовы

 ### ❓*Задание* (<span style="color:blue">средне</span>) Отслеживание системных вызовов

> В этом задании вы добавите функцию отслеживания системных вызовов, которая 
> может помочь вам при отладке последующих лабораторных работ. Вы создадите 
> новый системный вызов trace, который будет управлять трассировкой. Он должен 
> принимать один аргумент, целочисленную "маску", биты которой определяют, какие 
> системные вызовы следует отслеживать. Например, чтобы отследить системный 
> вызов fork, программа вызывает trace(1 << SYS_fork), где SYS_fork - это номер 
> системного вызова из kernel/syscall.h. Вам необходимо изменить ядро xv6, так, 
> чтобы оно выводило строку при возврате каждого системного вызова, если 
> номер системного вызова задается в маске. Строка должна содержать 
> идентификатор процесса, имя системного вызова и возвращаемое значение; вам не 
> нужно печатать аргументы системного вызова. Системный вызов trace должен 
> включать трассировку для процесса, который его вызывает, и любых дочерних 
> процессов, которые он впоследствии разветвляет, но не должен влиять на другие 
> процессы.

Мы даем программу трассировки пользовательского уровня, которая запускает другую программу с включенной трассировкой (см. user/trace.c). Когда вы закончите, вы должны увидеть результат, подобный этому:

```
$ trace 32 grep hello README
3: syscall read -> 1023
3: syscall read -> 966
3: syscall read -> 70
3: syscall read -> 0
$
$ trace 2147483647 grep hello README
4: syscall trace -> 0
4: syscall exec -> 3
4: syscall open -> 3
4: syscall read -> 1023
4: syscall read -> 966
4: syscall read -> 70
4: syscall read -> 0
4: syscall close -> 0
$
$ grep hello README
$
$ trace 2 usertests forkforkfork
usertests starting
test forkforkfork: 407: syscall fork -> 408
408: syscall fork -> 409
409: syscall fork -> 410
410: syscall fork -> 411
409: syscall fork -> 412
410: syscall fork -> 413
409: syscall fork -> 414
411: syscall fork -> 415
...
$
```
В первом примере выше trace вызывает трассировку grep только при системном 
вызове read. Значение 32 равно `1 << SYS_read`. Во втором примере trace запускает 
grep при отслеживании всех системных вызовов; для 2147483647 установлены все 31 
биты. В третьем примере программа не отслеживается, поэтому выходные данные 
трассировки не выводятся на печать. В четвертом примере отслеживаются системные 
вызовы fork всех потомков теста `forkforkfork` в `usertests`. Ваше решение 
правильное, если ваша программа ведет себя так, как показано выше (хотя 
идентификаторы процессов могут отличаться).

### Некоторые подсказки:

Добавьте `$U/_trace` к обновлениям в Makefile

Запустите `make qemu`, и вы увидите, что компилятор не может скомпилировать 
`user/trace.c`, поскольку заглушки пользовательского пространства для системного 
вызова еще не существуют: добавьте прототип системного вызова в `user/user.h`, 
заглушку в `user/usys.pl` , и номер системного вызова в `kernel/syscall.h`. 
Makefile вызывает perl-скрипт `user/usys.pl` , который создает `user/usys.S`, 
фактические заглушки системных вызовов, которые используют команду RISC-V ecall 
для перехода к ядру. Как только вы устраните проблемы с компиляцией, запустите 
trace 32 grep hello README; программа завершится ошибкой, потому что вы еще не 
реализовали системный вызов в ядре.

Добавьте функцию `sys_trace()` в `kernel/sysproc.c`, которая реализует новый 
системный вызов, запоминая ее аргумент в новой переменной в структуре `proc` 
(см. `kernel/proc.h`). Функции для извлечения аргументов системного вызова из 
пользовательского пространства находятся в `kernel/syscall.c`, и вы можете 
увидеть примеры их использования в `kernel/sysproc.c`.

Измените `fork()` (см. `kernel/proc.c`), чтобы скопировать маску трассировки из 
родительского процесса в дочерний.

Измените функцию `syscall()` в `kernel/syscall.c`, чтобы напечатать выходные 
данные трассировки. Вам нужно будет добавить массив имен системных вызовов для 
индексации.

Если тестовый пример проходит, когда вы запускаете его непосредственно внутри 
`qemu`, но при запуске тестов с помощью `make grade` вы получаете тайм-аут, то 
знайте некоторые тесты в этой лаборатории могут быть слишком трудоемкими с 
точки зрения вычислений для вашего локального компьютера (особенно если вы 
используете WSL).

Sysinfo (moderate)

In this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel/sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints "sysinfotest: OK".
Some hints:

Add $U/_sysinfotest to UPROGS in Makefile

Run make qemu; user/sysinfotest.c will fail to compile. Add the system call sysinfo, following the same steps as in the previous assignment. To declare the prototype for sysinfo() in user/user.h you need predeclare the existence of struct sysinfo:

    struct sysinfo;
    int sysinfo(struct sysinfo *);
  
Once you fix the compilation issues, run sysinfotest; it will fail because you haven't implemented the system call in the kernel yet.
sysinfo needs to copy a struct sysinfo back to user space; see sys_fstat() (kernel/sysfile.c) and filestat() (kernel/file.c) for examples of how to do that using copyout().

To collect the amount of free memory, add a function to kernel/kalloc.c

To collect the number of processes, add a function to kernel/proc.c

Optional challenge exercises

Print the system call arguments for traced system calls (easy).
Compute the load average and export it through sysinfo(moderate).