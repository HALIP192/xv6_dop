
# Лабораторная работа №1

## Вводная лабораторная по host OS, Makefile, GIT, Bash

Лабораторные работы проводятся по обучающей операционной системе xv6.

## Путеводитель по **ВСЕМ** лабораторным работам.

  Каждое задание будет помечено определенным цветом и подписью ассоциированным  
  со сложностью задания:

  * <span style="color:green"> *Легко* </span> - менее часа. Разминка.

  * <span style="color:blue"> *Средне* </span> - 1-2 часа.

  * <span style="color:red"> *Тяжело* </span> - Более 2 часов. Чаще не 
    много кода, но тяжело логически.

  Это время сильно завышено от наших лучших ожиданий. Для некоторых заданий мы  
  не можем точно определить сколько времени вам потребуется и поэтому тяжесть  
  указанная там - просто предположение. Если вы находите себя в трате большего  
  количества времени на задание чем предполагалось, то лучше отдохните, выпейте  
  кофе и вернитесь к выполнению чуть позже.

  Задания в целом **не требуют** много строчек кода написать (до нескольких  
  сотен в самых тяжелых. _P.S._ не пугайтесь, это не так сложно), но код  
  концептуально сложный и часто детали слишком важны. Так что, пожалуйста,  
  удостоверьтесь, что перед выполнением лабораторных вы прочитали и обдумали  
  задание, прочитали нужные файлы и литературу (мы постарались всегда указывать  
  что необходимо) и заглянули в документацию (мануал по _RISC-V_ и прочее будут  
  указаны как ссылки к курсу).

  Только когда у вас есть четкое понимание задания и решения - начинайте писать  
  код. Когда пишете код - пишите его по маленьким шагам и **не забывайте  
  коммитить код!!!** (Часто, большое и, на первый взгляд, не выполнимое задание,  
  при разбиении на задания поменьше становиться вполне выполнимым. Планируете  
  свою работу тщательно.) Не забывайте тестировать разные сценарии работы своего  
  кода, после написания каждого этапа. Это поможет избавиться от глобального  
  переписывания всего решения с 0 после обнаружения проблемы на этапе повыше.

  > Рекомендация: не начинайте делать лабы за ночь до сдачи. На много  
  эффективнее делать ее в несколько этапов. Выявление бага в операционной  
  системе может быть сложным заданием и для инженеров с большим опытом. Для
  этого нужно много думать, уметь аккуратно отлаживать код, чтобы понять, что не так,
  а еще и придумать как это починить.

Для выполнения лабораторных работ вам необходимо
начальное понимание того, что такое **LINUX**, **компилятор**,
и как пользоваться и взаимодействовать с операционной системой.
Так же это понадобится в будущем и для того, чтобы разрабатывать операционную систему. 
Расскажем об основных утилитах и том, как именно им пользоваться.

**_Ubuntu_** - один из наиболее известных дистрибутивов **самой** популярной и  
используемой ОС - LINUX. Как ни странно, многие и не подозревают на сколько  
произведение Финского гения (Линуса Торвальдса) непосредственно интерферирует с  
нашей жизнью каждый день. Примеры:

* Android &mdash; это очередной форк (англ. fork - вилка. Название появилось от  
системного вызова в Unix-like ОС - SYSCALL(fork). Который создает дочерний  
процесс). Как бы кто бы что бы не говорил - количество Android телефонов точно  
больше, чем всех остальных вместе.

* Сервера - почти все сервера в мире (кроме серверов Microsoft) давно уже  
перешли на серверные дистрибутивы LINUX. Не потому, что это просто удобней (не  
без этого, исходный код открыт как ни как). А просто потому, что это   
продуктивнее. Лучше 100-1000 специалистов Майкрософт, которые парятся за  
производительность или сотни тысяч энтузиастов, у которых зачастую не хуже опыт в  
разработке ОС, а даже получше. А есть ребята из Linux сообщества, имеющие  
исключительные знания - обычно из закрытых источников или эксклюзивных  
исследований, и часто, такие исключительные знания порождают значительные  
улучшения системы.

* Бытовая техника - да-да, в 80% бытовой техники на борту микроконтроллеров 
стоит тот или иной Linux.

**Дистрибутив** &mdash; это набор программ для начальной инициализации и последующего  
взаимодействия с системой. Чтобы напрямую взаимодействовать с системой нажмите  
_Сtrl+Alt+T_. У вас откроется терминал для прямого взаимодействия с системой.  
**$** - системный символ (каретка).  
Основные команды для взаимодействия c Linux через терминал:

> <span style="color:orange"> Рекомендация: </span> лучший способ понять, как  
> что-то делать  - интернет и ваши коллеги.

* <span style="color:green">_man_</span>  - Мануал для того, чтобы понять, что  
делает та или иная команда/функция. Исполните следующую строку.
  > $ man man

> <span style="color:orange"> Рекомендация: </span> Используйте _man_ для каждой  
команды указанных ниже.

* <span style="color:green"> _pwd_</span> - утилита для отображения, текущего  
местоположения (каталога) в системе

* <span style="color:green">_ls_</span> - команда просмотра того, что находится в  
директории.

* <span style="color:green">_cd_</span> - утилита перехода в другую директорию.

* <span style="color:green">_mkdir_</span> - утилита для создания директории.

* <span style="color:green">_rm_</span> - утилита для удаления с которой нужно  
быть ***ОЧЕНЬ*** аккуратным.

* <span style="color:green">_apt_</span> - утилита пакетного менеджера для  
установки чего-либо.

* <span style="color:green">_touch_</span> - утилита для создания файлов.

* <span style="color:green">_cat_</span> - утилита для отображения содержимого  
файла.

* <span style="color:green">_head_</span> - утилита для отображения ***первых  
N*** строк файла.

* <span style="color:green">_tail_</span> - утилита для отображения 
***последних N*** строк файла.

* <span style="color:green">_grep_</span> - утилита для поиска ***строк***, 
совпадающих по данному паттерну.

* <span style="color:green">_find_</span> - утилита для поиска ***файлов***, 
совпадающих по данному паттерну.

> <span style="color:orange"> Заметка:</span> Путь можно указывать  
> относительным (когда мы указываем путь относительно текущего положения) или  
> абсолютным (полный путь от корневой директории). Для указания текущей  
> директории можно использовать символ "**.**" а для предыдущей "**..**". В пути  
> после каждой директории нужно использовать символ "**/**".

### Текстовый редактор
Одна из важнейших вещей также для разработки - текстовый редактор. Наиболее 
популярные в разработке ОС - **vi**, **vim**, **emacs**, **neovim**.

  > ### *Задание* (<span style="color:green">лёгкоe</span>)   
  > Пройдите обучение в _vim_ набрав в терминале команду _vimtutor_

Vim не стандартный текстовый редактор для всех разработчиков программного  
обеспечения. Но один из самых распространенных для разработчиков ОС. По началу  
он будет казаться неудобным и вам не по душе, но, он конфигурируемый и, если  
понять основную логику самого _vim_, то написание кода ускориться в разы.

# Системы контроля версий

## Виды систем контроля

 - Git
 - Svn (Subversion)
 - Mercurial
 - Perforce
 - т.д.

## Принцип работы

?? Описать работу на примере diff и patch

## Основы Git

### Выполнить перед основной частью

Запустите скрипт, который создаст папку и файлы в ней.

    bash create_dir.sh
    bash create_dir.sh

После исполнения сценария в скрипте, у Вас создастся папка с именем *lab1*.
Перейдите в нее для выполнения последующих команд.

### Основная часть

#### <span style="color:grey">Создание репозитория</span>

Для создания репозитория в директории, где его еще нет - используется 
следующая команда.

    git init

Результатам использования данной команды будет созданный репозиторий.  

В случае если репозиторий уже был создан ранее, то вы можете склонировать 
это репозиторий к себе с помощью следующей команды.

    git clone url

> ### ❗️<span style="color:orange">Заметки</span>
> Ветка, используемая по умолчанию, называется **master**.  
> В зависимости от настроек репозитория она может называться **main** и т.д.  
> Подробнее о ветках будет рассказано дальше.

#### <span style="color:grey">Вывод состояния</span>

Давайте узнаем какие файлы в данный момент можно закоммитеть. Для этого 
используем следующую команду.

    $ git status

В результате должны получить следующее сообщение.

    On branch master

    No commits yet

    Untracked files:
    (use "git add <file>..." to include in what will be committed)
        hello_world.c

    nothing added to commit but untracked files present (use "git add" to track)

Рассмотрим данное сообщение подробнее. 
Первая строчка говорит нам на какой ветке происходят изменения. 
В нашем случае это ветка **master**. 
Следующей строчкой сообщается, что коммитов еще не было. 
Затем, идет сообщение о том какие файлы еще не отслеживаются в данный момент 
(в нашем случае это файл *hello_world.c*) или какие файлы были изменены.  

#### <span style="color:grey">Отслеживание файлов</span>

Давайте добавим наш файл в отслеживаемые. 
Для этого напишем команду, приведенную ниже.

    git add hello_world.c

После исполнения команды при проверке статуса мы можем увидеть сообщение, 
в котором говорится, что файл *hello_world.c* отслеживается, 
но изменения еще не закоммичены. 

    On branch master

    No commits yet

    Changes to be committed:
    (use "git rm --cached <file>..." to unstage)
        new file:   hello_world.c

#### <span style="color:grey">Создание коммита</span>

Для создания коммита используем следующую команду. 
После должен открыться текстовый редактор, 
в котором необходимо будет ввести сообщение для коммита.
    
    git commit
    git commit -m "Message" # сокращенный вариант, без вызова текстового редактора.

При успешном создании коммита будет выведено следующее сообщение.

    [master (root-commit) 7561abb] update: add file hello_world.c
    1 file changed, 6 insertions(+)
    create mode 100644 hello_world.c

#### <span style="color:grey">История коммитов</span>

Таким образом мы сделали наш первый коммит в репозиторий. 
Для просмотра истории коммитов можно использовать следующую команду.

    git log

Результатом команды будет сообщение состоящие из 
хэша коммита, автора, даты и изменений.

    commit 7561abb1172e2b1c5c027421be438187de43644a (HEAD -> master)
    Author: eestelle <yosiky@list.ru>
    Date:   Sat Sep 16 11:38:45 2023 +0300

    update: add file hello_world.c

#### <span style="color:grey">Удаленный репозиторий. Создание соединениея</span>

> ### ❗️<span style="color:orange">Заметки</span>
> Данный раздел нужен если репозиторий был создан, а не склонирован.

Ранее все команды были предназначены для работы с локальным репозиторием. 
Теперь рассмотрим, как отправить созданный нами коммит в удаленный репозиторий (на сервер/облако). 
Перед отправкой коммита необходимо связать наш репозиторий с удаленным, 
который находится на [github](https://github.com).

    git remote add origin url

> ### ❗️<span style="color:orange">Заметки</span>
> Для создания удаленного репозитория Вам сначала необходимо будет
> зарегистрироваться на платформе.  
> **Локальный репозиторий** &mdash; это репозиторий, находящийся на Вашей машине.  
> Список добавленных удаленных репозиториев 
> можно посмотреть с помощью команды **git remote**.

#### <span style="color:grey">Удаленный репозиторий. Отправка</span>

Ранее мы успешно соединили наш локальный репозиторий с удаленным. 
Теперь же отправим наши изменения в удаленный репозиторий.

    git push origin branch_name

В случае успешной отправки будет выведено сообщение следующего вида.

    Enumerating objects: 3, done.
    Counting objects: 100% (3/3), done.
    Delta compression using up to 10 threads
    Compressing objects: 100% (2/2), done.
    Writing objects: 100% (3/3), 976 bytes | 976.00 KiB/s, done.
    Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
    To github.com:Yosiky/check.git
    * [new branch]      master -> master

#### <span style="color:grey">Управление ветками. Введение в HEAD</span>

**HEAD** &mdash; это указатель на активный коммит или, другими словами, где мы находимся
в данный момент. При смене ветки из master в dev применяются коммиты с D и E.

##### Пример 1. **HEAD** - указывает на последний коммит в master.
```
            HEAD->master
                  |
    A ---> B ---> C 
```

##### Пример 2. **HEAD** - указывает на другую активную ветку.
```
                  master
                  |
    A ---> B ---> C 
                   \
                    D ---> E
                           |
                     HEAD->dev
```

#### <span style="color:grey">Управление ветками. Практика</span>

Для удобства ведения проекта, а также работы в команде 
был добавлен механизм под названием ветки.

Создание новой ветки можно осуществить двумя методами.  
Первый метод, позволяет создать ветку, но не переходить на нее
Второй метод, позволяет создать ветку и сразу же перейти на нее.

    git branch branch_name
    git checkout -b branch_name

Для переключения между уже имеющимися ветками можно команду switch.

    git switch branch_name


> ### ❗️<span style="color:orange">Заметки</span>
> В последующих лабораторных Вам необходимо будет использовать **git** и 
> **github** для сдачи лабораторных работ.

> ### ❓*Задание* (<span style="color:green">легко</span>)
> ✅ По ссылке в конце прорешать первые 3 главы в разделе **"Основы"**.  
> ✅ По ссылке в конце прорешать весь раздел **"Удаленные репозитории"**.  
> P.S.: Результат будет проверяться с помощью вопросов на основные команды.

------

## Полезные ссылки

https://learngitbranching.js.org - практические упражнения для git.  
https://git-scm.com/book/ru/v2 - теоретические сведения для работы с git. Есть английская версия. 

# Системы сборки

Система сборки - утилита или набор утилит для автоматизации сборки проекта.

В пределах нашего курса мы поговорим про самую известную систему сборки и по  
совместительству самую широко используемую для разработки ОС - ***Make***, а точнее уже  
стандартизированную ее версию - *GNU Make*.

## Основная часть

Для использования утилиты **make**, необходимо написать файл, называемый  
*makefile* в котором как правило описываются правила, описывающие взаимосвязь  
файлов, друг между другом и команды для обновления каждого файла. В программе  
обычно исполняемые файлы обновляются из объектных файлов, которые в свою очередь  
получаются при компиляции.

Как только такой файл будет представлена, то, как только вы сделаете изменения  
в соурс(англ. source - источник) файлах, написав такую простую команду:

``` bash
  $ make
```

Все необходимые к пересборке части будут пересобраны. Утилита **make** 
использует базу данных из *makefile* и даты обновления чтобы понять какие файлы  
необходимо пересобрать. Для каждого такого файла, будут запущенны  
соответствующие этому файлу правила.

## Makefile

Давайте создадим свой *makefile* для сборки нашего **hello_world.c** как  
тренировку для понимания того, как можно удобно использовать **make**. Следуем  
следующему алгоритму:

* Создадим файл "Makefile" в этом же каталоге. Для этого используем утилиту **touch**.

``` bash
  $ touch Makefile
```

* Теперь для сборки нашего файла необходимо задать его имя, путь, компилятор, ну  
и стандартные флаги. А после этого стандартные для каждого мейкфайла правила.

``` make
1  NAME = hello_world
2 
3  СС = clang
4  CFLAGS = -Wall -Wextra -Werror
5
6  SRC = hello_world.c
7  SRC_PATH = lab1
8
9  OBJS_PATH = obj
10 OBJS = $(addprefix $(OBJS_PATH)/, $(patsubst %.c, %.o, $(SRC)))
11 
12 all: $(OBJS_PATH) $(NAME)
13
14 clean:
15         rm -rf $(OBJS_PATH)
16
17 $(OBJS_PATH): 
18         mkdir -p $@
19
20 $(OBJS): $(SRC_PATH)/$(SRC) Makefile
21         $(CC) $(CFLAGS) $< -c -o $@
22
23 $(NAME): $(OBJS) Makefile
24         $(CC) $(LDFLAGS) $(OBJS) -o $@
25
26 .PHONY: clean
```

Не пугайтесь, мейкфайл универсальная вещь - его достаточно 1 раз написать, а  
дальше его можно переиспользовать во всех проектах, просто поменяв переменные.

Теперь рассмотрим все что мы написали подробнее.

### Автоматические переменные

**$@** - Имя файла, которое является целью правила. Если целью является архив, 
то будет имя архива. Если паттерном правила будет множество целей, то это будет 
любая цель, которая заставила правило сработать.

**$%** - Имя целевого файла, если целью является архив.

**$<** - Название первого обязательного условия. Если цель получил свой рецеп 
из неявного правила, то это будет первым условием в неявном правиле.

**$?** - Имена всех обязательных условий, которые новее чем цель с пробелами 
между ними. Если цель не существует, все условия будут включены.

**$^** - Имена всехъ условий через пробел, *не* содержащих копии. Так же не 
содержит условий выполняющихся только по порядку.

**\$+** - такое же правило как и **$^** но содержащие повторения.

Больше информации по мейку тут - [GNU make]

### Встроенные функции

У мейкфайла есть встроенные функции, как в пашем примере **addprefix** и 
**patsubst**. Первая добавляет в аргумент 2 строку аргумента 1 и возвращаем ее. 
Вторая же функция заменяет в строке аргумента 3, подстроку в ней паттерна 
аргумента 1 на аргумент 2. Больше о функциях можно такжде посмотреть вот 
тут - [GNU make]

### Переменные

Объявление переменных (строчки 1-10 в примере выше) в мейкфайлах происходит по  
принципу:

``` make
[имя переменной] = [значение]
```

Переменная так же может служить списком, так для его объявления делаем примерно  
тоже самое.

```make
[имя переменной] = [значение1] [значение2] ... [значениеn]
```

Но, правилом хорошего тона, а часто и обязательным правилом, будет вот такой вид  

```make
[имя переменной] = [значение1] \
                   [значение2] \
                   ... \
                   [значениеn]
```

Здесь, символ **\\** служит переходом на следующую строку. Такой вид, как можно  
понять повышает читаемость и, как нам кажется, эстетическую красоту.

### Правила

Правило в мейкфайле, это строчки вида:

```make
[цель] ... : [зависимость] ...
          [действие]
          ...
          ...
```

Как можно заметить правила в мейкфайле представленном ранее будет всё с 12  
строки (исключая **.PHONY**). *Цель* &mdash; это имя файла который нужно 
сгенерировать. Но также *цель* может быть действием, которое не привязано не к  
какому реальному объекту (Например правила *clean*. Смотри [Phony Targets]).

> ### ❓*Задание* (<span style="color:green">легко</span>)
> ✅ Создайте правило **mrproper**, которое будет удалять все объектные файлы и  
> удалять исполняемый файл.  
> ✅ Создайте правило **re** которое будет пересобирать все файлы, вне  
> зависимости от того надо ли это делать или нет.

> ### <span style="color:orange"> Рекомендация: </span>  
> Все вышесказанное далеко даже не треть того что умеет **make** и что можно  
> делать в *makefile*, но этого достаточно для прохождения дальнейшего курса.  
> Для более глубокого познания **make** советуем смотреть [GNU make]

[Phony Targets]: https://www.gnu.org/software/make/manual/make.html#Phony-Targets
[GNU make]: https://www.gnu.org/software/make/manual/make.html
