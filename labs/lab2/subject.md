# Настройка окружения для выполнения лабораторных работ

Дальнейший Курс лабораторных работ включает в себя - лабораторные работы по ОС
Xv6 а так же книга о ней, на которую будут ссылаться работарные работы.

### Презентация - [тут]

## Начальное приготовление, подготовка окружения, репозитория

Для выполнения работы необходимо **обязательно** выполнить следующие действия
для подготовки:

* выполнить следующие команды и проверить результат:

  ```bash
  $ cd ~/path-to-project/xv6-labs
  $ git config --global user.name "First and Second Name"
  $ git config --global user.email "mail@example.com"
  ```

**После** выполнения вышеперечисленных комманд необходимо удостоверится в том,
что все что нам необходимо присутствует:

* Проверяем что эмулятор есть:

  ```bash
    $ qemu-system-riscv64 --version
    QEMU emulator version 5.1.0
  ```

* Проверяем что хотя бы какая-то версия RISC-V GCC установлена:

  ```bash
   $ riscv64-linux-gnu-gcc --version
   riscv64-linux-gnu-gcc (Debian 10.3.0-8) 10.3.0
   ...

   $ riscv64-unknown-elf-gcc --version
   riscv64-unknown-elf-gcc (GCC) 10.1.0
   ...

   $ riscv64-unknown-linux-gnu-gcc --version
   riscv64-unknown-linux-gnu-gcc (GCC) 10.1.0
   ...
  ```

## Советы по отладке

  Вот несколько советов для отладки вашего решения:

* Убедитесь что вы точно понимаете _С_ и _указатели в С_. (Об этом
  можно почитать в книге "The C programming language (second edition)" Kernighan, Ritchie).
  Посмотрите на этот участок и убедитесь что вы понимаете все что
  происходит и почему получается именно такой результат.

``` c
 #include <stdio.h>
 #include <stdlib.h>

  void f(void)
  {
      int a[4];
      int *b = malloc(16);
      int *c;
      int i;

      printf("1: a = %p, b = %p, c = %p\n", a, b, c);

      c = a;
      for (i = 0; i < 4; i++)
          a[i] = 100 + i;
      c[0] = 200;
      printf("2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
             a[0], a[1], a[2], a[3]);

      c[1] = 300;
      *(c + 2) = 301;
      3[c] = 302;
      printf("3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
              a[0], a[1], a[2], a[3]);

      c = c + 1;
      *c = 400;
      printf("4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
              a[0], a[1], a[2], a[3]);

      c = (int *) ((char *) c + 1);
      *c = 500;
      printf("5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n",
              a[0], a[1], a[2], a[3]);

      b = (int *) a + 1;
      c = (int *) ((char *) a + 1);
      printf("6: a = %p, b = %p, c = %p\n", a, b, c);
  }

 int
 main(int ac, char **av)
 {
     f();
     return 0;
 }
```

Несколько советов по указателям, которые точно надо вспомнить:

* Если p = (int *)100, тогда (int)p + 1 и (int)(p + 1) - **совершенно разные
числа**: первое 101, но второе 108. Когда вы прибавляете целочисленное число к
указателю, число **автоматически** умножается на размер типа указателя. (В нашем
случае sizeof(int *) == 8)
* p[i] **Одно и тоже** что и *(p = i). Оба варианта вернут вам значение i-го
элемента в памяти на которую указывает указатель p.

* &p[i] **Тоже самое** что и (p + i). Оба варианта вернут вам **адресс** i-го
элемента в памяти на которую указывает указатель p.

И еще, большая часть программ написанных на _C_ никогда не приводят типы из
указателей в целые числа, но в разработке операционных систем это сплошь и
рядом. Каждый раз когда вы видите строчку кода задействующую работу с памятью,
то спросите себя это целое число или указатель и убедитесь правильно ли
произведено сложение/умножение или нет.

* Если ваше задание частично сделано - **сохранитесь**, сделав коммит в git.
Если вы что-то сломаете, всегда можно будет откатиться назад и продолжить. Чтобы
больше узнать о системе контроля версий смотрете [Git's user manual],
лабораторную работу №1 (часть про гит), или попросите вашего преподавателя
рассказать немного о гите и, если у него будет хорошее настроение - он вам
обязательно поможет. :)

* Если тесты на ваше задания не проходят - убедитесь что вы точно понимаете
почему это происходит. Вставте printf() с нужной вам информацией пока не поймете
в чем дело. Не бегите раньше времени к преподавателю с криками о том что тесты
не правильны. (we have zero trust policy to you).

* Принты часто сильный инструмент для отладки, но иногда возможность пошаговой
отладки в ассемблере или проверка переменных на стеке бывает очень полезна.
Чтобы использовать **gdb** на xv6 запустите make qemu-dbg в одном окне и
gdb-multiarch (или riscv64-linux-gnu-gdb) в другом. Поставте точку останова и
исполняйте программу пошагово используя команду `n` (next). Чтобы перейти к следующей точке останова используйте команду `c` (continue). xv6 исполнит все иструкции до точки останова, а далее вы сможете исполнять код пошагово. Смотри
[GDB manual]. (Если gdb выдает сообщения о возможной ошибке -
`warning: File .../.gdbinit auto-loading has been declined`, то нужно поправить
`~/.gdbinit` и добавить строку "add-auto-load-safe-path..." в файл, как предлагается в сообщении
об ошибке.)
* Смотри [cюда] для советов по GDB

* Если нужно посмотреть ассемблер который генерирует компилятор для Xv6 ядра или
надо посмотреть какие инструкции в конкретных адресах ядра - смотри
`kernel/kernel.asm`, которые генерирует Makefile когда собирает ядро (Makefile также делает и .asm файлы для всех пользовательских программ).

* Если ядро выдает неожиданную ошибку (например invalid memmory adress), оно выведет сообщение об ошибке которое включает адрес исполнаяемой инструкции (`program counter`, регистр `sepc`) в момент
когда произошло падение. Вы можете найти функцию
которая содержит в себе program counter в файле `kernel/kernel.asm`, или можно запустить команду

``` bash
$ addr2line -e kernel/  kernel _аддрес_
```

> <span style="color:orange"> Рекомендация: </span> man addr2line для  подробностей

Если хочешь получить стек вызовов - перезапусти с gdb: запусти
`make qemu-gdb` в одном окне, поставь точку останова на функцию паники(`b panic`),
нажми `c` чтобы продолжить и когда ядро достигнет ее, нажми `bt` чтобы получить стек вызовов функций.

* Если ядро зависло - это скорее всего из-за дедлока (англ. deadlock - взаимоблокировка) можно найти место, где оно зависло используя gdb. Запусти `make qemu-dbg` в одном окне и `gdb` (`riscv64-linux-gnu-gdb`) в другом. Когда
ядро зависнет, нажми `Ctrl+C` в окне с `qemu-dbg` и нажми `bt` чтобы получить стек вызовов.

* У qemu есть "монитор" который позволяет запрашивать состояние эмулированной
машины. Его можно вызвать с помощью `Ctrl+A с` ("c" для консоли). Особенно полезна
команда монитора `info mem` чтобы напечатать таблицу страниц. Еще вам может понадобиться команда
`cpu`, чтобы выбрать у какого ядра смотреть `info mem`. Так же, вы можете
запустить _qemu_ с заданной переменной _CPUS_: `make CPUS=1 qemu` чтобы запустить ее в одноядерном режиме.
Чтобы выйти из режима монитора нажмите еще раз `Ctrl+A c`

***Стоит уделить достаточно времени для изучения вышеупомянутых инструментов,
они помогут вам не только чтобы сдать лабораторные работы и не только чтобы
разрабатывать операционные системы, но и в целом на любой работе, связанной с
написанием кода***

## Основная часть: Xv6 и Unix утилиты

Сборка и запуск Xv6: для этого нужно написать команду `make qemu`, при этом будет примерно такой вывод:

```bash
$ make qemu
riscv64-unknown-elf-gcc -c -o kernel/entry.o kernel/entry.S
riscv64-unknown-elf-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie   -c -o kernel/start.o kernel/start.c
...
riscv64-unknown-elf-ld -z max-page-size=4096 -N -e main -Ttext 0 -o user/_zombie user/zombie.o user/ulib.o user/usys.o user/printf.o user/umalloc.o
riscv64-unknown-elf-objdump -S user/_zombie > user/zombie.asm
riscv64-unknown-elf-objdump -t user/_zombie | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$/d' > user/zombie.sym
mkfs/mkfs fs.img README  user/xargstest.sh user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie
nmeta 46 (boot, super, log blocks 30 inode blocks 13, bitmap blocks 1) blocks 954 total 1000
balloc: first 591 blocks have been allocated
balloc: write bitmap block at sector 45
qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0

xv6 kernel is booting

hart 2 starting
hart 1 starting
init: starting sh
$
```

Если напишем `ls` в командную строку, должны получить следующий вывод:

```bash
$ ls
.              1 1 1024
..             1 1 1024
README         2 2 2227
xargstest.sh   2 3 93
cat            2 4 32864
echo           2 5 31720
forktest       2 6 15856
grep           2 7 36240
init           2 8 32216
kill           2 9 31680
ln             2 10 31504
ls             2 11 34808
mkdir          2 12 31736
rm             2 13 31720
sh             2 14 54168
stressfs       2 15 32608
usertests      2 16 178800
grind          2 17 47528
wc             2 18 33816
zombie         2 19 31080
console        3 20 0
```

Это файлы что **mkfs** включил как исходную файловую систему. Большую часть
програм вы можете запустить. Вы только что запустили одну из них: `ls`

В Xv6 нет программы `ps` - программы для отображения всех запущенных процессов.
Но вы можете нажать `Ctrl+p` и ядро само выпишет всю информацию о каждом процессе
Если попробуете это сейчас, то увидите 2 пункта: один *init* и второй *sh*.

Чтобы выйти из эмулятора - нажмите `Ctrl+A x` (нажмите Ctrl + A комбинацией, и только потом отдельно х).

### sleep (<span style="color:green">легко</span>)

  > Реализуйте пользовательскую программу `sleep` для xv6. Такую же как и **sleep** в **UNIX**. Ваша программа должна сделать паузу на обозначенное количество *тиков*. Тик это определенное ядром xv6 некоторое количество времени, обычно время между двумя прерываниями из таймера чипа. Ваша решение должно быть в *user/sleep.c*.

  Некоторые советы:

  * Перед тем как начать писать код, прочтите 1 главу книги [xv6 book].
  * Ваш код должен быть находиться в файле *user/sleep.c*. Посмотрите на другие программы в каталоге *user/* (например *echo*, *grep*, *rm*) чтобы понять как аргументы командной строки передаются в программу.
  * Добавте вашу **sleep** программу в `UPROGS` в `Makefile`. Как только вы ее добавите, выполните команду `make qemu` чтобы ваша программа скомпилировалась и вы смогли ее запустить внутри xv6.
  * Если пользователь забыл передать аргументы, программа должна сообщить об ошибке и коректно завершиться.
  * Аргументы через командную строку приходят как строки. Вы можете их конвертировать в числа (например в целочисленные с помощью функции `atoi`, см. *user/ulib.c*).
  * Используйте системный вызов `sleep`.
  * Ядерный код системного вызова **sys_sleep** находится в файле *kernel/sysproc.c*. Импортируйте файл *user/user.h* для того чтобы получить определение функции вызываемой из пользовательского пространства, Ассемблер код, который переключает исполнение из пользовательского пространства в пространство ядрв находится в файле *user/usys.S*.
  * функция `main()` в *sleep.c* должна вызывать `exit()` после окончания.
  * Чтобы больше узнать о языке **Си** можно почитать книгу "The C programming language (second edition)" Kernighan, Ritchie.

Запуск программы из xv6 shell:

```bash
$ make qemu
...
init: starting sh
$ sleep 10
(ничего не происходит в течение 10 секунд)
$
```

Ваше решение верно если программа делает то что показанно выше. Запусти **make grade** чтобы увидеть прошели ли вы тест на sleep.

Помни что **make grade** запускает все тесты включая на те задания что ниже. Если вы хотите запустить тест отдельный для 1 задания, то запустите:

```c
 $ ./grade-lab-util sleep
```

Это запустит тест на sleep. Ну или запустите его вот так:

```c
 $ make GRADEFLAGS=sleep grade
```

Что запустит то же самое.

### pingpong (<span style="color:green">легко</span>)

  > Напишите юзерспейс программу для xv6 которая бы использовала системные вызовы для "пинг понга" байта между 2 процессами через пару пайпов(pipes - трубы), по одной в каждую сторону. Родитель должен послать байт ребенку, ребенок должен написать "<pid>: received ping", где <pid> это айди процесса, написать байт в пайп родителю и выйти; родитель должен прочитать байт от ребенка, написать "<pid>: received pong", и выйти. Ваше решение должно быть написано в user/pingpong.c.

  Подсказки:
  * Добвте файл с программой в UPROGS в Makefile.
  * Используйте *pipe* для создания пайпа.
  * Используйте *fork* для создания дочернего процесса.
  * Используйте *read* для пайпа приема и *write* для пайпа посылки.
  * Используйте get_pid() для понимания айди процесса исполняющегося.
  * Юзерспейсные программы в xv6 имеют ограниченное количество библиотек доступных для подключения.

  Запуск программы должен выдавать следующий вывод:

  ```c
  $ make qemu
    ...
    init: starting sh
    $ pingpong
    4: received ping
    3: received pong
    $
  ```

  Ваше решение верно если ваша программа обменивается байтами между 2 процессами и выводит вывод как показано.

### primes (<span style="color:blue">cредне</span>/<span style="color:red">тяжело</span>)

  > Напишите программу prime sieve для xv6 с пайпами и дизайном показанным ниже в середине страницы, и окзружающий тест. Эта идея принадлежит Дугу Макилрою, изобретателю Unix pipes. Ваше решение должно быть написано в файле user/primes.c.

Ваша цель - используя pipe и fork для настройки вашего конвеера. Первый процесс передает число от 2 до 25 через конвеер. Для каждого простого числа в жтом промежутке  создается 1 процесс который читает от одного своего соседа процесса слева и передает результат соседу справа. Поскольку xv6 имеет ограниченное количество файловых дескрипторов и процессов, первый процесс останавливается на числе 35.

Подсказки:
* Будте осторожны с закрытие файловых дискрипторов без надобности. Иначе процесс может остаться без ресурсов до того как первый достигнет 35.
* Как только первый процесс достиг 35, он должен ждать пока весь конвеер не остановится, включая детей, правнуков и тд. Поэтому начальный процесс моджет заканчиваться только тогда когда все что надо было напечататьнапечатано и все родстевенники закончили исполнение.
* read возвращает 0 когда пишущая часть пайпа закрылась.
* Проще сразу писать по 32 битных числам в пайп чем передавать числа в формате ASCII
* Вы доллжны создавать дочерние процессы в конвеере только в случает необходимости.
* Добавте файл с кодом в UPROGS в Makefile.

Если реализация верна, то конвеер должен вывести что-то похожее:

```c
 $ make qemu
    ...
    init: starting sh
    $ primes
    prime 2
    prime 3
    prime 5
    prime 7
    prime 11
    prime 13
    prime 17
    prime 19
    prime 23
    prime 29
    prime 31
    $
```
### Find (средняя сложность)
Напишите простую версию программы UNIX find для xv6 (`man find`). Программа должна найти все файлы в дереве каталогов с определенным именем. Ваше решение должно быть в файле **user/find.c**.

Несколько подсказок:
 - Посмотрите реализацию `ls` (см. **user/ls.c**), чтобы узнать, как читать каталоги.
 - Используйте рекурсию, чтобы искать по подкаталогам.
 - Не продолжайте рекурсию в каталогах **"."** (текущий каталог) и **".."** (родительский каталог).
 - Изменения в файловой системе сохраняются при всех запусках qemu. Чтобы получить чистую файловую систему, запустите `make clean`, а затем `make qemu`.
 - Вам придется использовать C строки *(англ C-strings)*. Про них можно почитать в книге **"The C Programming Language, Kernighan, Ritchie"**, раздел 5.5.
 - Обратите внимание, что оператор `==` не сравнивает строки, как, например, в *Python*. Вместо этого используйте `strcmp` (`man strcmp`).
 - Добавьте файл с программой в переменную `UPROGS` в **Makefile**.


Ваше решение должно будет иметь следующий вывод (когда файловая система содержит файлы *b*, *a/b* и *a/aa/b*):
```bash
$ make qemu
...
init: starting sh
$ echo > b
$ mkdir a
$ echo > a/b
$ mkdir a/aa
$ echo > a/aa/b
$ find . b
./b
./a/b
./a/aa/b
$
```
### xargs (средняя сложность)
Напишите простую версию UNIX программы `xargs` (`man xargs`) для xv6.
**Xargs** получает в качестве аргумента команду для запуска, считывает строку из стандартного ввода и добавляет ее в конец команды из аргументов, и в конце исполняет сформированную команду. Ваше решение должно быть в файле *user/xargs.c*.
Следующий пример иллюстрирует поведение **xargs**:
```bash
$ echo World | xargs echo Hello
Hello World
$
```

Обратите внимание, что изначальная команда - `echo Hello`, а дополнительные аргументы - `World`, и в итоге получается команда `echo Hello World`, которая выводит `Hello World`.

Пожалуйста, обратите внимание, что xargs в UNIX выполняет оптимизацию, при которой он будет минимизировать количество создаваемых процессов, стараясь объединять несколько вызовов в один. Мы не ожидаем, что вы проведете такую оптимизацию. Чтобы заставить xargs в UNIX вести себя так, как мы хотим для этой лабораторной работы, пожалуйста, запустите его с параметром `-n 1`. Например
```bash
$ echo Alice Bob | xargs -n 1 echo Hello
Hello Alice
Hello Bob
$
```

[Git's user manual]: https://mirrors.edge.kernel.org/pub/software/scm/git/docs/user-manual.html
[GDB manual]: https://pdos.csail.mit.edu/6.828/2019/lec/gdb_slides.pdf
[cюда]: https://pdos.csail.mit.edu/6.1810/2023/labs/gdb.html
[тут]: https://docs.google.com/presentation/d/1qIwJu_Lr2r5dTBd8YxDEA7odrmWCRgkz7R3-cfUbWj8/edit?usp=sharing